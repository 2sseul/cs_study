# 운영체제란 무엇이고 목적이 무엇인지 설명해주세요.

## 운영체제란

    유저와 하드웨어 간의 인터페이스 역할을 하는 소프트웨어입니다.
    OS로 하여금 하드웨어의 구조를 몰라도 유저가 성능을 이끌어 낼 수 있습니다.

    목적 1. 유용한 사용자 프로그램을 실행할 수 있는 환경을 제공해 줍니다.
    ⇒ 직접적으로 운영체제가 유용한 것은 아니지만, 유용한 프로그램이 실행될 수 있도록 환경을 제공해줍니다.

    목적 2. 하드웨어의 자원을 효율적으로 사용하게 만듭니다.

    ⇒ 유저가 직접 자원(CPU, Main Memory, I/O Device, File System 등)관리를 하게 하지 않습니다.

    추가적으로 프로세스 관리, 기억장치 관리, 주변장치 관리, 파일 관리를 담당합니다.

<br><br>

# 메모리가 어떻게 구성되어있는지 설명해주세요.

    메모리는 크게 코드, 데이터, 스택, 힙 영역으로 나누어져 있습니다.

    코드 영역은 실행될 프로그램의 코드가 저장되어 있는 영역입니다.

    데이터 영역은 전역 변수와 정적 변수 그리고 리터럴 값이 저장되어 있는 영역입니다.

    스택 영역은 지역변수와 매개 변수(파라미터)가 저장되어있으며 함수의 호출과 함께 할당 되는 영역입니다.

    힙 영역은 사용자에 의해 동적으로 할당되고 해제될 수 있는 메모리 영역입니다.

<br><br>

# 가상 메모리를 사용하는 이유가 무엇인지 설명해주세요.

    물리 메모리는 컴퓨터에 장착된 실제 메모리로 최대 크기는 CPU에 의해서 제한이 됩니다.

    ex) 32-bit CPU에서는 4GB이상의 물리 메모리 이상 사용이 불가능하다.

    이때 프로세스의 주소 공간은 4GB로 고정되어 있는데 프로세스가 동작이 가능한지 부터 생각 해보아야합니다. 만약 프로세스가 실행되기 위해서는 프로세스 전체를 물리 메모리에 적재해야하는가를 고민해봅시다.

    우리 컴퓨터는 일부 메모리만을 적재한 채 실행 될수 있고, 실제로는 모든 프로세스를 메모리에 올려놓지 않아도 됩니다.

    가상 메모리란 프로세스의 적재 공간을 메모리에서 보조 기억 장치의 영역까지 사용하게 하기 위해서 사용하는 것입니다. 실제 한정된 메모리 용량을 효율적으로 사용하기 위해서 사용함.

    - 참고자료 : [가상 메모리 등장한 이유, 가상 메모리 이용하는 원리](https://eunjinii.tistory.com/61)

<br><br>

# 프로세스와 스레드의 차이에 대해서 설명해주세요.

### 프로세스

    정의 : 메모리에 올라와 실행되고 있는 프로그램의 인스턴스

    특징 :
    1. 운영체제로부터 독립된 메모리 영역을 할당받는다. (다른 프로세스의 자원에 접근 X)
    2. 프로세스들은 독립적이기 때문에 통신하기 위해 IPC를 사용해야한다.
    여기서 IPC란?
    프로세스들 사이에 서로 데이터를 주고받는 행위 또는 그에 대한 방법이나 경로를 뜻한다.
    주요 방식으로는 파일, 신호, 소켓, 메시지 큐, 파이프, 지명 파이프, 세마포어, 공유 메모리 등이 있다.
    3. 프로세스는 최소 1개의 스레드(메인 스레드)를 가지고 있다.

### 스레드

    정의 : 프로세스 내에서 할당받은 자원을 이용해 동작하는 실행 단위

    특징 :
    1. 스레드는 프로세스 내에서 Stack만 따로 할당 받고 Code, Data, Heap 영역은 공유합니다.(Stack을 분리한 이유는 Stack에는 함수의 호출 정보가 저장되는데, Stack을 공유하면 LIFO 구조에 의해 실행 순서가 복잡해지기 때문에 실행 흐름을 원활하게 만들기 위함입니다.)
    2. 스레느는 프로세스의 자원을 공유하기 때문에 다른 스레드에 의한 결과를 즉시 확인할 수 있다.
    3. 프로세스 내에 존재하며 프로세스가 할당받은 자원을 이용하여 실행된다.

-   프로세스는 다른 프로세스와 정보를 공유하려면 IPC를 사용하는 등의 번거로운 과정을 거쳐야 하지만, 스레드는 기본 구조 자체가 메모리를 공유하는 구조이기 때문에 다른 스레드와 정보 공유가 쉽습니다. 때문에 멀티태스킹보다 멀티스레드가 자원을 아낄 수 있게 됩니다. 다만 스레드의 스케줄링은 운영체제가 처리하지 않기 때문에 프로그래머가 직접 동기화 문제에 대응할 수 있어야 합니다.

<br><br>

# 멀티 프로세스와 멀티 스레드의 차이

### 멀티프로세스

    정의 : 하나의 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 1개의 작업을 처리하도록 하는 것.
    특징 :
    1. 1개의 프로세스가 죽어도 자식 프로세스 이외의 다른 프로세스들은 계속 실행된다.
    2. Context Switching을 위한 오버헤드(캐시 초기화, 인터럽트 등)가 발생한다.

    여기서 Context Switching이란?
    - Context Switching이란 인터럽트를 발생시켜 CPU에서 실행중인 프로세스를 중단하고, 다른 프로세스를 처리하기 위한 과정입니다. Context Switching는 현재 실행중인 프로세스의 상태(Context)를 먼저 저장하고, 다음 프로세스를 동작시켜 작업을 처리한 후에 이전에 저장된 프로세스의 상태를 다시 복구합니다. 여기서 인터럽트란 CPU가 프로세스를 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요함을 CPU에게 알리는 것을 말합니다.

    3. 프로세스는 각각 독립적인 메모리를 할당받았기 때문에 통신하는 것이 어렵다.

### 멀티 스레드

    정의 : 하나의 프로그램을 여러 개의 스레드로 구성하여 각 스레드가 1개의 작업을 처리하도록 하는 것.
    특징 :
    1. 프로세르르 위해 자원을 할당하는 시스템콜이나 Context Switching의 오버헤드를 줄일 수 있습니다.
    2. 스레드는 메모리를 공유하기 때문에, 통신이 쉽고, 자원을 효율적으로 사용할 수 있습니다.
    3. 하나의 스레드에 문제가 생기면 전체 프로세스가 영향을 받습니다.
    4. 여러 스레드가 하나의 자원에 동시에 접근하는 경우 자원 공유(동기화)의 문제가 발생할 수 있습니다.

    멀티스레드 프로그래밍 작성 시 유의점
    - 멀티 쓰레드 프로그램을 개발한다면, 다수의 쓰레드가 공유 데이터에 동시에 접근하는 경우에 상호 배제를 제거해 교착 상태를 예방하고 동기화 기법을 통해 동시성 문제가 발생하지 않도록 발생하지 않도록 주의해야 합니다.

<br><br>

# 교착상태에 대해 설명해주세요.

    정의 : 교착상태(데드락)는 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 상황을 말합니다.

    교착상태의 4가지 조건
    비선점 (Nonpreemptive)
    - 다른 프로세스의 자원을 뺏을 수 없음.
    순환 대기 (Circular wait)
    - 두 개 이상의 프로세스가 자원 접근을 기다릴 때, 관계가 순환적 구조.
    점유 대기 (Hold & Wait)
    - 공유 자원에 대한 접근 권한을 가진 채로 다른 자원에 대한 접근 권한을 요구.
    상호 배제(Mutual Exclusion)
    -  한 번에 한 프로세스만 공유 자원에 접근 가능하며, 접근 권한이 제한적일 경우.

## 교착상태의 (Deadlock)의 해결법

    1) 교착상태 예방(Prevention)
    교착상태의 발생조건 4가지 중 하나라도 발생하지 않게 하는 것

    자원의 상호 배제 조건 방지 : 한 번에 여러 프로세스가 공유 자원을 사용할 수 있게 한다.
    점유 대기 조건 방지 : 프로세스 실행에 필요한 모든 자원을 한꺼번에 요구하고 허용할 때까지 작업을 보류해서, 나중에 또다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 한다.
    비선점 조건 방지 : 이미 다른 프로세스에게 할당된 자원이 선점권이 없다고 가정할 때, 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 한다.
    순환 대기 조건 방지 : 자원을 순환 형태로 대기하지 않도록 일정한 한 쪽 방향으로만 자원을 요구할 수 있도록 함.

    2)  교착상태 회피(Avoidance)
    Safe state : 시스템의 프로세스들이 요청하는 모든 자원을, 데드락을 발생시키지 않으면서도 차례로 모두에게 할당해 줄 수 있는 상태

    Safe sequence :  특정한 순서로 프로세스들에게 자원을 할당, 실행 및 종료 등의 작업을 할 때 데드락이 발생하지 않는 순서

    회피 알고리즘 : 자원을 할당한 후에도 시스템이 항상 Safe state에 있을 수 있도록 할당을 허용하자는 것이 기본 특징

    은행원 알고리즘(Banker’s Algorithm)
    다익스트라가 제안한 기법으로, 어떤 자원의 할당을 허용하는지에 관한 여부를 결정하기 전에, 미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션 해서 Safe state에 들 수 있는지 여부를 검사한다. 즉 대기중이 다른 프로세스들의 활동에 대한 교착 상태 가능성을 미리 조사하는 것

    은행원 알고리즘의 경우, 이처럼 미리 최대 자원 요구량을 알아야 하고, 할당할 수 있는 자원 수가 일정해야 하는 등 사용에 있어 제약조건이 많고, 그에 따른 자원 이용도 하락 등 단점도 존재

## 데드락 탐지(Detection) 및 회복(Recovery)

    탐지 기법
    Allocation, Request, Available 등으로 시스템에 데드락이 발생했는지 여부를 탐색합니다. 즉, 은행원 알고리즘에서 했던 방식과 유사하게 현재 시스템의 자원 할당 상태를 가지고 파악합니다.
    이 외에도 자원 할당 그래프를 통해 탐지하는 방법도 있습니다.
    회복 기법
    단순히 프로세스를 1개 이상 중단시키기
    교착 상태에 빠진 모든 프로세스를 중단시키는 방법 : 계속 연산중이던 프로세스들도 모두 일시에 중단되어 부분 결과가 폐기될 수 있는 부작용이 발생할 수 있음
    프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복시키는 방법 : 매번 탐지 알고리즘을 호출 및 수행해야 하므로 부담이 되는 작업일 수 있음
    자원 선점하기
    프로세스에 할당된 자원을 선점해서, 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해 주는 방법
    데드락을 탐지 기법을 통해 발견했다면, 순환 대기에서 벗어나 데드락으로부터 회복하기 위한 방법

<br><br>

# 동기와 비동기의 차이에 대해 설명해주세요.

![image](./image/image10.png)
동기는 순차적, 직렬적으로 테스크를 수행하고, 비동기는 병렬적으로 테스크를 수행합니다.
예를 들어, 서버에서 데이터를 가져와서 화면에 표시하는 작업을 수행할 때,
동기는 서버에 데이터를 요청하고 데이터가 응답될 때까지 이후 테스크들은 블로킹(Blocking, 작업 중단)됩니다.
비동기는 서버에 데이터를 요청한 이후 서버로부터 데이터가 응답될 때까지 대기하지 않고(Non-Blocking) 즉시 다음 테스크를 계속해 수행합니다.

## Synchronous & Asynchronous 의 차이

-   둘의 차이는 함수가 다른 함수를 호출한 이후, 호출된 함수의 작업 완료 여부에 신경을 쓰는지의 여부에 있습니다.

-   Synchronous : 다른 함수를 호출한 이후에 해당 함수가 작업을 완료했을 때 리턴을 받거나 작업을 완료했는지 지속적으로 확인하는 방식을 통해 신경씁니다.

-   Asynchronous : 호출한 함수는 호출된 함수의 작업 완료 여부에 대해 확인받거나 물어보는 과정없이 신경쓰지 않습니다.

-   이를 구현하기 위해 호출된 함수는 별도의 thread를 생성하여 자신의 작업을 실행하며, 완료 시 callback 함수를 통해 완료 여부를 알려주게 됩니다.

<br><br>

# 선점형 스케줄링과 비선점형 스케줄링의 차이를 설명해주세요.

-   선점형은 하나의 프로세스가 다른 프로세스 대신에 CPU를 차지할 수 있음
-   비선점형은 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음을 말합니다.

<br><br>

# 뮤텍스(Mutex)와 세마포어(Semaphore)의 차이에 대해 설명해주세요.

## 뮤텍스

    프로세스나 스레드가 공유 자원을 lock()을 통해 잠금 설정하고 사용한 후에는 unlock()을 통해 잠금을 해제하는 객체 입니다. 잠금 설정시 다른 프로세스나 스레드는 잠긴 코드 영역에 접근할 수 없다.
    뮤텍스는 Lock을 사용해 하나의 프로세스나 쓰레드를 단독으로 실행하게 합니다.

## 세마포어

    일반화된 뮤텍스입니다. 간단한 정수 값과 두가지 함수 wait, signal로 공유 자원에 대한 접근을 처리해 줍니다.
    여기서 wait()은 자신의 차례가 올 때까지 기다리는 함수이며, signal()은 다음 프로세스로 순서를 넘겨주는 함수입니다.
    세마포어는 공유자원에 세마포어 변수만큼의 프로세스(또는 쓰레드)가 접근할 수 있습니다.

    세마포어의 변수 → 공유자원의 개수를 나타내는 변수

-   현재 수행중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있지만 뮤텍스는 락(lock)을 획득한 프로세스가 반드시 그 락을 해제해야 합니다.

-   0과 1의 값만 갖는 세마포어 → 이진 세마포어(binary semaphore) (= 뮤텍스)

-   도메인 제한이 없는 세마포어(0,1 뿐만아니라 2,3,4 등의 값들 또한 가질 수 있는) → 카운팅 세마포어(counting semaphore)
