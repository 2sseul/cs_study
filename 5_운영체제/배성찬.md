# **Page Fault 를 줄이는 방법**에 대해서 설명하세요.

✅ **Page Fault(페이지 부재라고도 함)란?**

    - 필요로 하는 페이지, 또는 요청한 주소가 메모리에 적재되어 있지 않은 경우

✅ **Page Replacement(페이지 교체)**

    - 비어있는 Frame 이 없는 경우 수행됨
    - 어떤 Frame 을 빼앗아올지 결정해야함
    - 동일한 페이지가 여러 번 메모리에서 쫓겨났다가 다시 들어올 수 있음

✅ **Page Replacement Algorithm 의 종류**

    ① Optimal Algorithm (=Min Algorithm)

    - 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체
    - 이론적으로 가장 최적의 알고리즘
    - 다른 알고리즘의 성능을 측정하는 기준점이 됨
    - 각 페이지의 호출 순서와 참조 상황을 미리 예측해야하므로 실현 가능성이 희박

    ② FIFO Algorithm

    - 각 페이지가 주기억장치에 적재될 때마다 시간을 기억시켜 그 시간을 기준으로 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체
    - Belady's Anomaly(벨레이디의 모순현상) : FIFO 알고리즘에서 기존 페이지 프레임의 개수를 늘리면 Page Fault 발생이 감소해야하나, 오히려 늘어나는 현상

    ③ LRU(Least Recently Used) Algorithm

    - 최근에 가장 오랫동안 사용하지 않은 페이지를 교체

    ④ LFU(Least Frequently Used) Algorithm

    - 사용빈도가 가장 적은 페이지를 교체
    - 프로그램 실행 초기에 많이 사용된 페이지가 그 후로 사용되지 않을 경우에도 프레임을 계속 차지하는 단점이 존재

<br><br>

# **시스템 콜**과 **함수 호출**의 차이에 대해서 설명하세요.

|                  | 시스템 콜                               | 함수 호출                                                        |
| ---------------- | --------------------------------------- | ---------------------------------------------------------------- |
| 정의             | 운영체제에 정의된 함수를 호출하는 것    | 자신이 작성한 함수 혹은 라이브러리에 저장된 함수를 호출하는 것   |
| 수행 공간        | 커널 주소 공간(커널 모드)               | 사용자 주소 공간(사용자 모드)                                    |
| 메모리 할당 여부 | 별도로 사용자 모드에서 메모리 할당 필요 | 특별한 할당이 없이도 라이브러리 함수에서 할당된 메모리 이용 가능 |

<br><br>

# **인터럽트**와 **시스템 콜**의 차이에 대해서 설명하세요.

    시스템 호출은 시스템에 내장 된 서브 루틴에 대한 호출이고 인터럽트는 이벤트로 프로세서가 현재 실행을 일시적으로 유지하게합니다. 그러나 한 가지 주요 차이점은 시스템 호출은 동기식이지만 인터럽트는 그렇지 않다는 것입니다. 즉, 시스템 호출은 고정 된 시간 (일반적으로 프로그래머가 결정)에 발생하지만 사용자가 키보드를 누르는 것과 같은 예기치 않은 이벤트로 인해 언제든지 인터럽트가 발생할 수 있습니다. 따라서 시스템 호출이 발생할 때마다 프로세서는 복귀 할 위치 만 기억하면되지만 인터럽트 발생시 프로세서는 복귀 할 위치와 시스템 상태를 모두 기억해야합니다. 시스템 호출과 달리 인터럽트는 일반적으로 현재 프로그램과 관련이 없습니다.

<br><br>

# 가상 메모리란? 가상 메모리는 구체적으로 어떻게 구현되는 지 알고 있나요?

    메모리가 실제 메모리보다 많아 보이게 하는 기술로, 어떤 프로세스가 실행될 때 메모리에 해당 프로세스 전체가 올라가지 않더라도 실행이 가능하다는 점에 착안하여 고안되었다.

    - 애플리케이션이 실행될 때, 실행에 필요한 일부분만 메모리에 올라가며 애플리케이션의 나머지는 디스크에 남게 됨. 즉, 디스크가 RAM의 보조 기억장치(backing store)처럼 작동하는 것임.

    ⇒ 결국 빠르고 작은 기억장치(RAM)을 크고 느린 기억장치(디스크)와 병합하여, 하나의 크고 빠른 기억장치(가상 메모리)처럼 동작하게 하는 것임.

    - 가상 메모리를 구현하기 위해서는 컴퓨터가 특수 메모리 관리 하드웨어를 갖추고 있어야만 함. ⇒ 바로 MMU(Memory Management Unit)

![image](./image/image9.jpeg)

    예전에는 MMU가 이와 같이 따로 분리된 하드웨어였지만 최근의 아키텍처에서는 프로세서와 같은 칩에 회로로 삽입된다.

    - MMU는 하고, 하는 기능을 수행함.
        1. 가상주소를 물리주소로 변환
        2. 메모리를 보호
    - MMU를 사용하게 되면, CPU가 각 메모리에 접근하기 이전에 메모리 주소 번역 작업이 수행됨.
    - 그러나 메모리를 일일이 가상 주소에서 물리적 주소로 번역하게 되면 작업 부하가 너무 높아지므로, MMU는 RAM을 여러 부분(페이지, pages)로 나누어 각 페이지를 하나의 독립된 항목으로 처리함.
    - 페이지 및 주소 번역 정보를 기억하는 작업이 가상 메모리를 구현하는 데 있어 결정적인 절차임.

<br><br>
