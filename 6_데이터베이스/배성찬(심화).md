# 트랜잭션이란?

<span style="background-color: orange; font-weight: bold; color: white; font-size: 25px; padding: 10px; border-radius: 10px">답변 예시</span>

##### ✅ 트랜잭션이란 하나의 논리적 기능을 수행하기 위한 작업의 단위로, 보통 데이터베이스에서는 데이터베이스 상태를 변화시키기 위해 수행하는 작업 단위를 의미합니다.

<br/>

트랜잭션이란 **데이터베이스의 일관성있는 상태를 다른 것으로 변경하는 작업 순서**를 말합니다. 데이터베이스의 상태를 변경시킨다는 이야기는 SELECT, UPDATE, INSERT, DELETE 와 같은 행동을 뜻합니다. 즉 데이터베이스 작업의 단위로써 하나 이상의 쿼리를 처리할 때 동일한 Connection 객체를 공유하여 에러가 발생한 경우 모든 과정을 되돌리기 위한 방법입니다. 트랜잭션 완료 후 성공적인 완료가 시스템에 반영되거나 트랜잭션이 실패하고 변경 사항이 반영되지 않습니다. 하나의 트랜잭션은 Commit (작업 완료) 되거나 Rollback (취소) 됩니다.

# 트랜잭션의 ACID

트랜잭션의 4가지 성질인 ACID는 **원자성**, **일관성**, **독립성**, **지속성**을 말합니다.

#### Atomicity(원자성)

트랜잭션의 연산이 DB에 모두 반영되던지 전혀 반영이 되지 않던지 둘중에 하나만 수행한다.

#### Consistency(일관성)

트랜잭션이 성공적으로 완료된 후에는 언제나 일관성 있는 DB상태로 유지해야 한다.

#### Isolation(독립성)

수행중인 트랜잭션이 완전히 완료되기 전에는 다른 트랙잭션에서 수행 결과를 참조할 수 없다.

#### Durablility(지속성)

성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

<hr/>

# RDBMS 와 NoSQL 의 차이점

<span style="background-color: orange; font-weight: bold; color: white; font-size: 25px; padding: 10px; border-radius: 10px">답변 예시</span>

✅ SQL 은 테이블로 이루어진 관계형 데이터베이스를 다루기 위해 사용되는 언어를 의미하며, NoSQL 은 보통 테이블 형식이 아닌 비관계형 형식으로 데이터를 관리하는 데이터베이스를 의미합니다.
NoSQL 은 각 데이터베이스마다 데이터를 다루는 언어가 다르지만, SQL 과 달리 데이터 구조가 고정되어 있지 않고, 유연하기 때문에 다양한 데이터를 다루는 빅데이터 분야에서 장점을 가지고 있습니다.

<br/>

#### RDBMS

- 모든 데이터를 2차원 테이블 형태로 표현

- 장점 : 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.
- 단점 : 시스템이 커질 수록 쿼리가 복잡해지고 성능이 저하되며 Scale-out 이 어렵다.

#### NoSQL (SQL 만을 사용하지 않는 데이터베이스)

- 데이터 간의 관계를 정의하지 않고, 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있으며, 컬렉션이라는 형태로 데이터를 관리하는 비관계형 DB

- 장점 :
  - 스키마 없이 Key-Value 형태로 데이터를 관리해 자유롭게 데이터를 관리할 수 있다.
  - 데이터 분산이 용이하며 성능 향상을 위한 Scale-up 뿐만 아닌 Scale-out 또한 가능
- 단점
  - 데이터 중복이 발생할 수 있고, 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야 한다.
  - 스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않아 데이터 구조 결정이 어려울 수 있다.

# RDBMS 와 NoSQL 은 어느 경우에 적합한가?

#### RDBMS

**데이터 구조가 명확하고, 변경 될 여지가 없으며 스키마가 중요한 경우 사용하는 것이 좋습니다.**

또한 중복된 데이터가 없어(데이터 무결성) 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합합니다.

#### NoSQL

**정확한 데이터 구조를 알 수 없고 데이터가 변경 / 확장 될 수 있는 경우 사용하는 것이 좋습니다.**

또한 단점에서도 명확하듯 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 시 모든 컬렉션에서 수정해야 하기 때문에 Update 가 많이 이루어지지 않는 시스템에 좋으며, Scale-out 이 가능하다는 장점을 활용해 막대한 데이터를 저장해야 해서 DB 를 Scale-out 해야 되는 시스템에 적합합니다.

<br><br>
<br><br>
<br><br>
<br><br>
<br><br>
<br><br>
<br><br>
<br><br>
<br><br>
<br><br>
<br><br>
<br><br>
<br><br>
<br><br>
<br><br>

# 인덱스를 사용해야 하는 경우랑 사용을 피해야 하는 경우는?

## 사용하면 좋은 경우

    1. WHERE 절에서 자주 사용되는 칼럼
    2. 외래 키가 사용되는 칼럼
    3. 조인에 자주 사용되는 칼럼

## 사용을 피해야 하는 경우

    1. 데이터 중복도가 높은(카디널리티가 낮은) 칼럼 e.g) 성별
    2. DML이 자주 일어나는 칼럼

    e.g) INSERT - 기존 블록(데이터베이스에서 데이터를 저장하는 가장 작은 단위)에 여유가 없을 때, 새로운 데이터가 입력된다. 새로운 블록을 할당받은 후, 키를 옮기는 작업을 수행하므로 많은 REDO(트랜잭션을 재수행)가 유발된다.


    +) 추가

    인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는데는 빠르지만 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려집니다.
    결론적으로 DBMS에서 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능입니다. `SELECT`쿼리 문장의 `WHERE` 조건절에 사용되는 칼럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있습니다.

<br><br>

# Inner Join과 Outer Join의 차이에 대해서 설명해주세요.

## INNER JOIN

    - 조인의 양쪽 테이블 모두 레코드가 존재하는 경우에만 레코드가 반환된다. 즉 교집합이라고 보면 된다. NNER JOIN된 결과를 보면 A 테이블과 B테이블이 모두 가지고 있는 데이터만이 검색된다.

```sql
select * from A inner join B on A.번호 = B.번호;
select * from A,B where A.번호=B.번호;
```

## OUTER JOIN

    - FULL OUTER JOIN의 경우 빼고는 특정 테이블을 기준으로 데이터를 보여준다. OUTER JOIN은 Full OUTER JOIN / LEFT OUTER JOIN / RIGHT OUTER JOIN 크게 세가지 종류로 나누어 진다.

    1. LEFT OUTER JOIN

    Left Outer Join 왼쪽 테이블 기준으로 JOIN 하겠다는 것. 왼쪽 테이블 A의 모든 데이터와 A와 B 테이블의 중복데이터들이 검색됨

```sql
select * from A LEFT OUTER JOIN B ON (A.번호 = B.번호)
select * from A, B Where A.번호(+) = B.번호;
```

    2. RIGHT OUTER JOIN

    RIGHT OUTER JOIN은 오른쪽 테이블 기준으로 JOIN 하겠다는 것

    3. FULL OUTER JOIN

    FULL OUTER JOIN은 왼쪽 테이블과 오른쪽 테이블의 합집합을 얻는다. 만약 A에는 데이터가 있지만 B에 데이터가 없으면 B부분은 null이 되고 반대의 경우에는 A부분이 null이 된다.

    • OUTER JOIN은 INNER JOIN에서 일치하지 않는 레코드는 모두 버렸던 것과 달리 OUTER JOIN에서는 일치하지 않더라도 버리지 않고 NULL로 채워서 결과를 응답한다.

<br><br>
