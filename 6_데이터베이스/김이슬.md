# 트랜잭션 동시성 제어 해결 방안

    - 트랜잭션: DBMS에서 데이터를 다루는 논리적인 작업의 단위

    ex) 게시물을 수정하는 과정에서 select와 update가 실행

    ⇒ 두 개의 쿼리문이 트랜잭션으로 묶이며, 하나의 트랜잭션이 실행될 때 2개의 쿼리문이 실행된다.

    ⇒ 두 개의 쿼리문이 하나의 트랜잭션으로 묶여있다고 가정할 때, 1개의 sql문만 실행되는 일은 발생하지 않는다(All or Nothing) = Atomicity(원자성)

    - **동시성 제어**: 여러 사용자가 있는 환경에서 둘 이상의 트랜잭션이 동시에 실행될 때, 데이터의 일관성을 해치지 않도록 하는 제어법

    ex) 초콜릿을 아껴먹으려고 10개를 서랍에 넣어놨는데 내가 모르는 사이 동료가 훔쳐먹었다. 나는 10개가 있겠지 하고 서랍을 열었는데 없다 ..!

    cf) 동시성 제어의 목적

    - 트랜잭션의 직렬성 보장
    - 공유도 극대화, 응답 시간 최소화, 시스템 활용의 극대화
    - 데이터의 무결성과 일관성 보장

**동시성 제어 기법의 종류**

| 제어 기법               | 설명                                                                                                                                                                                                                      |
| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| 락킹(locking)           | - 트랜잭션이 데이터에 잠금(lock)을 설정하면 다른 트랜잭션은 해당 데이터에 대해 잠금이 해제(unlock)될 때까지 접근/수정/삭제가 불가하다. 트랜잭션이 사용하는 자원에 대하여 상호 배제(Mutual Exclusive) 기능을 제공하는 기법 |
| 타임스탬프(timestamp)   | - 시스템에서 생성하는 고유 번호인 타임스탬프를 트랜잭션에 부여함으로써 트랜잭션간의 접근 순서를 미리 정한다.                                                                                                              |
| 적합성(validation) 검증 | - 먼저 트랜잭션을 수행하고 트랜잭션을 종료할 때 적합성을 검증하여 데이터베이스에 최종 반영한다                                                                                                                            | ※ 상호배제는 특정 트랜잭션이 데이터 항목에 대하여 잠금 (Lock)을 설정할 트랜잭션이 해제(unlock) 할 때 까지 데이터를 독점적으로 사용할 수 있는 것 |

**동시성 제어하지 않는 경우 문제점**

| 구분                          | 설명                                                                                                                                                                                                                                    |
| ----------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 갱신 손실 (Lost Update)       | - 하나의 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어씀으로써 갱신이 무효화가 되는 것을 의미 - 두 개이상 트랜잭션이 한 개의 데이터를 동시에 갱신(Update)할 때 발생                                                                     |
| 현황파악오류 (Dirty Read)     | - 읽기 작업을 하는 트랜잭션 1이 쓰기 작업을 하는 트랜잭션2가 작업한 중간 데이터를 읽기 때문에 발생하는 문제 <br> - 작업중인 트랜잭션 2가 작업을 Rollback한 경우 트랜잭션 1은 무효가 된 데이터를 읽게 되고 잘못된 결과를 도출한다.       |
| 모순성 (Inconsistency)        | - 다른 트랜잭션들이 해당 항목 값을 갱신하는 동안 한 트랜잭션이 두 개의 항목 값 중 어떤 것은 갱신되기 전의 값을 읽고 다른 것은 갱신된 후의 값을 읽게 되어 데이터의 불일치가 발생하는 상황                                                |
| 연쇄복귀 (Cascading Rollback) | - 두 트랜잭션이 동일한 데이터 내용을 접근할 때 발생 <br> - 한 트랜잭션이 데이터를 갱신한 다음 실패하여 Rollback 연산을 수행하는 과정에서 갱신과 Rollback 연산을 실행하고 있는 사이에 해당 데이터를 읽어서 사용할 때 발생할 수 있는 문제 |

출처 : [[ 기술면접 / 데이터베이스 ] 동시성 제어( Concurrency Control )](https://jokerkwu.tistory.com/125)

<br><br>

# 정규화의 장단점과 이상현상에 대해 설명하세요

## 장점

    - 데이터 베이스 변경 시 이상현상 문제점을 해결할 수 있다.
    - 데이터베이스 구조 확장 시 정규화된 데이터베이스는 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.

## 단점

    - 분해로 인해 릴레이션 간 연산이 많아진다. 그렇기 때문에 질의에 대한 응답이 느려질 수 있다.
    - 이상현상
    - 테이블을 설계할 때 잘못 설계하여 데이터를 삽입, 삭제, 수정할 때 생기는 논리적 오류

    1) 삽입 이상: 자료를 삽입할 때 특정 속성에 해당하는 값이 없어 NULL을 입력해야하는 현상

    2) 갱신 이상: 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상

    3) 삭제 이상: 어떤 정보를 삭제하면, 의도하지 않은 다른 정보까지 삭제되는 현상

<br><br>

# 역정규화를 하는 경우는 어떤 경우일까요?

## 역정규화를 해야하는 이유

    - 정규화의 단점으로 언급 되었던 것이 비용(Cost)이다. 데이터베이스의 비용을 최소화 하기 위해 중복을 허용하며 Entity를 다시 통합하거나 분할하여 정규화 과정을 통해 도출된 DB구조를 재조정하는 것이다.
    - Join이 너무 많아지는 DB설계와 쿼리는 요청을 처리하는데 시간을 증가시키는 문제가 있습니다. 모든 주요 Entity를 분리하는 것만이 좋은 것이 아니라 DB전반적인 성능을 향상 시킬 수 있는 구조화 과정을 거치는 것이 필요합니다.

또는

    - 정규화된 데이터베이스 구조는 릴레이션 분해로 인해 릴레이션 간 연산 수가 증가합니다. 이로 인해 데이터베이스 질의에 대한 응답 시간이 느려질 수 있습니다.
    - 중복된 데이터를 제거하는 정규화는 데이터 저장 공간을 절약하지만, 데이터를 읽어오는 시간과 비용을 증가시킬 수 있습니다.
    - 일부 조회 요청은 정규화된 데이터베이스 구조에서는 여러 릴레이션 간의 조인 연산이 필요할 수 있습니다. 이는 데이터베이스 성능을 저하시킬 수 있습니다.
    - 때로는 릴레이션 간의 연관성을 고려하여 중복된 데이터를 허용하는 것이 쿼리 성능을 향상시키고 데이터베이스의 확장성을 높일 수 있습니다.

    따라서, 데이터베이스에서는 성능과 확장성을 고려하여 반정규화를 수행할 필요가 있습니다.
